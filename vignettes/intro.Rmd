---
title: "Introduction"
output:
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    number_sections: true
    code_folding: show
    collapse: false
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE)
```

# Load
```{r}
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(tibble))
suppressPackageStartupMessages(library(DBI))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(simaerep))
```

# Introduction

Simulate subject-level event reporting of clinical trial sites with the goal of detecting over- and under-reporting.

Monitoring reporting rates of subject-level clinical events (e.g.
adverse events, protocol deviations) reported by clinical trial sites is an
important aspect of risk-based quality monitoring (RBQM) strategy. Sites that are 
under-reporting or over-reporting events can be detected using bootstrap
simulations during which patients are redistributed between sites. Site-specific
distributions of event reporting rates  are generated that are used to assign
probabilities to the observed reporting rates.
  
The method is inspired by the 'infer' R package and Allen Downey's blog article: ["There is only one test!"](
http://allendowney.blogspot.com/2011/05/there-is-only-one-test.html).

## Why use {simaerep}?

Patient-level events during a clinical study do not occur randomly at visits but
they are heavily dependent on the underlying study protocol and the planned procedures.
We have illustrated this in our simulated test data by sampling event rates from
a gamma distribution with higher rates for early visits and low rates for late visits.

Typically most RBQM tools calculate a ratio between the site event count and the
number of patient, the days that they spend on study or the number of visits. Then
they employ some outlier detection method to detect outliers (e.g. box plot statistics,
percentiles, funnel plots). All of these methods assume a constant event rate
over the course of the study or that all patients started the trial at the same time.

In a simulation experiments we could show that {simaerep} outperforms these methods [see
documentation](https://openpharma.github.io/simaerep/articles/funnel_perf.html).

{simaerep} has also been positively evaluated by three different industry members for the
purpose of detecting sites that are under-reporting adverse events [Koneswarakantha et al. 2024](https://doi.org/10.1007/s40264-020-01011-5).

## Algorithm

1) Record initial site-level events per visits rate
2) Replace every patient with a random patient with the same number of visits
3) Record site-level events per visits rate for new set of patients
4) Repeat 3) 1000 times to obtain site-specific events per visits rate distribution.
5) Determine probability to obtain initial site-level events per visits rate from 1) using the distribution generated in 4)
6) Adjust probabilities using the [Benjamin Hochberg Procedure](https://www.statisticshowto.com/benjamini-hochberg-procedure/) in order to correct alpha error.


## Sample Data

### Patient

Patient level AE data is characterized by the number of consecutive visits and the number of AEs that have been reported each time. For the maximum consecutive visit we sample from a normal distribution and for the AEs reported at each visit we sample from a poisson distribution.

Here we simulate the AEs generated by 3 patients

```{r}

set.seed(1)

replicate(
   3,
   sim_test_data_patient(
    .f_sample_max_visit = function() rnorm(1, mean = 20, sd = 4),
    .f_sample_event_per_visit = function(max_visit) rpois(max_visit, 0.5)
  )
)

```

### Study

In order to simulate patient data for an entire study we assume make the simplification that all sites have the same number of patients. Further we specify a fraction of sites that is under-reporting events.

We sample event_rates from a gamma distribution to reflect the non-constant event rates.

```{r}

set.seed(1)

df_visit <- sim_test_data_study(
  n_pat = 100, # number of patients in study
  n_sites = 10, # number of sites in study
  ratio_out = 0.1, # ratio of sites with outlier
  factor_event_rate = -0.5, # rate of under-reporting
  # non-constant event rates based on gamma distribution
  event_rates = (dgamma(seq(1, 20, 0.5), shape = 5, rate = 2) * 5) + 0.1,
  max_visit = 20,
  max_visit_sd = 10,
  study_id = "A"
)


df_visit %>%
  head(10) %>%
  knitr::kable()

df_visit %>%
  select(site_id, is_out) %>%
  distinct() %>%
  knitr::kable()
```

In our sample data 1 sites (S0001) is under-reporting events.

## Algorithm Execution

### Standard

The column `event_prob` contains the reporting probability for each site as values
between -1 and 1. Under- and over-reporting probabilities are inversely related and
have been combined into one column. Negative values show high under-reporting,
positive values higher over-reporting.

The column `event_delta` shows the difference of events expected minus the events
reported.


```{r}
evrep <- simaerep(df_visit)
evrep
```


```{r}
plot(evrep, study = "A")
```

*Left panel shows mean cumulative event reporting per site (blue lines) against mean cumulative event reporting of the entire study (golden line). Sites with either high under-reporting (negative probabilities) or high over-reporting (positive probabilities) are marked by grey dots and plotted in additional panels on the right. N denotes the number of sites. Right panel shows individual sites with total patient cumulative counts as grey lines. N denotes the number of patients, the percentage the under- and over-reporting probability and \u0394 denotes the difference compared to the expected number of events.*

### Illustrate Probability Scoring

We can illustrate the probability scoring by increasing the number of sites and 
switching off the multiplicity correction and not introducing any outlier.

Note that none of these sites are actually outlier but high scores are the
results of repetitive testing.

```{r}
df_visit <- sim_test_data_study(
  n_pat = 1000, # number of patients in study
  n_sites = 100, # number of sites in study
  # non-constant event rates based on gamma distribution
  event_rates = (dgamma(seq(1, 20, 0.5), shape = 5, rate = 2) * 5) + 0.1,
  max_visit = 20,
  max_visit_sd = 10,
  study_id = "A"
)

evrep <- simaerep(df_visit, mult_corr = FALSE)
evrep

plot(evrep, study = "A")
```

### Multiple Event Types

We can calculate scores for multiple event types in one go. This time we add a site
outlier with 50% over-reporting.

```{r}

set.seed(1)

event_names <- c("x", "y")

df_visit <- sim_test_data_study(
  n_pat = 1000, # number of patients in study
  n_sites = 100, # number of sites in study
  # non-constant event rates based on gamma distribution
  ratio_out = 1/100, # ratio of sites with outlier
  factor_event_rate = +0.5, # rate of over-reporting
  event_names = event_names,
  event_rates = list(
    (dgamma(seq(1, 20, 0.5), shape = 5, rate = 2) * 5) + 0.1,
    (dgamma(seq(1, 20, 0.5), shape = 4, rate = 2) * 5) + 0.05
  ),
  max_visit = 20,
  max_visit_sd = 10,
  study_id = "A"
)

df_visit %>%
  select(site_id, patient_id, visit, n_x, n_y)
```

```{r}
evrep <- simaerep(df_visit, event_names = event_names)
evrep
```

```{r}
plot(evrep, study = "A", plot_event = "x")

plot(evrep, study = "A", plot_event = "y")

```

### Input Data Requirements

As input data the cumulative event count for each patient visit is required.

```{r}

df_visit <- sim_test_data_study()

df_visit %>%
  filter(patient_id == "P000001") %>%
  select(site_id, patient_id, visit, n_event) %>%
  knitr::kable()
```

In practice this requires data from different domains within the clinical data set
to be merged. This requires the patient and site ids as well as the date and time
at which visits and events are occurring. 

There will be edge cases e.g. missing dates, missing patient link, events and visits
on the same date, that require attention.

[gsm.simaerep::InputCumCount](https://impala-consortium.github.io/gsm.simaerep/reference/Input_CumCount.html) that is part of the gsm extension [`gsm.simaerep`](https://github.com/IMPALA-Consortium/gsm.simaerep) 
uses subject, visit and event data as input and merges the data into a `simaerep`
ready data frame.

However, it follows the `gsm` naming conventions so the column names will be different
than those required by `simaerep`. We can adapt to the different column names in the
following way.

`gsm.simaerep` has not yet been released on CRAN so we are not demonstrating it's 
functionality here.


```{r}

df_visit_gsm <- df_visit %>%
  mutate(
    study_id = "A"
  ) %>%
  select(
    StudyID = study_id,
    GroupID = site_id,
    SubjectID = patient_id, 
    Denominator = visit, 
    Numerator = n_event
  )

simaerep(
  df_visit_gsm,
  col_names = list(
    study_id = "StudyID",
    site_id = "GroupID",
    patient_id = "SubjectID",
    visit = "Denominator",
    n_ae = "Numerator"
  )
)

```

## Multiple Studies

`simaerep` probabilities can be calculated for multiple studies at once.

```{r}

df_visit <- bind_rows(
  sim_test_data_study(study_id = "A"),
  sim_test_data_study(study_id = "B")
)

simaerep(df_visit)
```

## In Database Calculation

We can demonstrate the database-backend compatibility by using a connection to a in memory `duckdb` database. In order to set the number of replications we need to create a new table in our back-end that has one column with as many rows as the desired replications.

A lazy reference to this table can then be passed to the `r` parameter.

```{r}
con <- DBI::dbConnect(duckdb::duckdb(), dbdir = ":memory:")
df_r <- tibble(rep = seq(1, 1000))

df_visit <- sim_test_data_study(ratio_out = 1/20, factor_event_rate = 0.5)

dplyr::copy_to(con, df_visit, "visit")
dplyr::copy_to(con, df_r, "r")

tbl_visit <- tbl(con, "visit")
tbl_r <- tbl(con, "r")

evrep_db <- simaerep(tbl_visit, r = tbl_r)
```

When inspecting `df_eval` we see that it is still a lazy table object.

```{r}
evrep_db
```

We can convert it to sql code. The `cte` option makes the sql code more readable.

```{r}
sql_eval <- dbplyr::sql_render(evrep_db$df_eval, sql_options = dbplyr::sql_options(cte = TRUE))
stringr::str_trunc(sql_eval, 500)
```

We can take that code and wrap it in a `CREATE TABLE` statement

```{r}
sql_create <- glue::glue("CREATE TABLE eval AS ({sql_eval})")
DBI::dbExecute(con, sql_create)
```

Retrieve the new table from the database.

```{r}
tbl_eval <- tbl(con, "eval")
tbl_eval
```

We plot the results from the {simaerep} object.

```{r}
plot(evrep_db, study = "A")
```

Or more efficiently by using `plot_study()` when we have already written the `simaerep` results into the database.
Here we avoid that the results are being recalculated just for the sake of creating a plot.

```{r}

plot(evrep_db, df_eval = tbl_eval, study = "A")

```


```{r}
DBI::dbDisconnect(con)
```




