# satisfy lintr
# lintr falsely flags possibly_ecdf as unused variable
if (getRversion() >= "2.15.1") {
  utils::globalVariables(c("possibly_ecdf"))
}

#' @title evaluate sites
#' @description correct under-reporting probabilities using  \code{\link[stats]{p.adjust}}.
#' @param df_sim_sites dataframe generated by \code{\link[simaerep]{sim_sites}}
#' @param method character, passed to stats::p.adjust(), if NULL
#' eval_sites_deprecated() is used instead, Default = "BH"
#' @param ... use to pass r_sim_sites parameter to eval_sites_deprecated()
#' @return dataframe with the following columns:
#' \describe{
#'   \item{**study_id**}{study identification}
#'   \item{**site_number**}{site identification}
#'   \item{**visit_med75**}{median(max(visit)) * 0.75}
#'   \item{**mean_ae_site_med75**}{mean AE at visit_med75 site level}
#'   \item{**mean_ae_study_med75**}{mean AE at visit_med75 study level}
#'   \item{**pval**}{p-value as returned by \code{\link[stats]{poisson.test}}}
#'   \item{**prob_low**}{bootstrapped probability for having mean_ae_site_med75 or lower}
#'   \item{**pval_adj**}{adjusted p-values}
#'   \item{**prob_low_adj**}{adjusted bootstrapped probability for having mean_ae_site_med75 or lower}
#'   \item{**pval_prob_ur**}{probability under-reporting as 1 - pval_adj, poisson.test (use as benchmark)}
#'   \item{**prob_low_prob_ur**}{probability under-reporting as 1 - prob_low_adj, bootstrapped (use)}
#'
#' }
#' @examples
#' df_visit <- sim_test_data_study(n_pat = 100, n_sites = 5,
#'     frac_site_with_ur = 0.4, ur_rate = 0.6)
#'
#' df_visit$study_id <- "A"
#' df_site <- site_aggr(df_visit)
#'
#' df_sim_sites <- sim_sites(df_site, df_visit, r = 100)
#'
#' df_eval <- eval_sites(df_sim_sites)
#' df_eval
#'
#' # use deprecated method  -------
#' df_eval <- eval_sites(df_sim_sites, method = NULL, r_sim_sites = 100)
#' df_eval
#' @rdname eval_sites
#' @seealso \code{\link[simaerep]{site_aggr}},
#' \code{\link[simaerep]{sim_sites}},
#' \code{\link[stats]{p.adjust}}
#' @importFrom stats p.adjust
#' @export
eval_sites <- function(df_sim_sites,
                        method = "BH",
                        ... ) {


  if (is.null(method)) {
    warning("using deprecated method for probability adjustment to expected false discovery rate")
    df_out <- eval_sites_deprecated(df_sim_sites, ...)
    return(df_out)
  }

  df_out <- df_sim_sites

  if ("pval" %in% names(df_out)) {

    if (anyNA(df_out$pval)) {
      warning("pval column contains NA")
    }

    df_out <- df_out %>%
      group_by(.data$study_id) %>%
      arrange(.data$study_id, .data$pval) %>%
      mutate(
        pval_adj = p.adjust(.data$pval, method = method),
        pval_prob_ur = 1 - .data$pval_adj
      )
  }

  if ("prob_low" %in% names(df_out)) {

    if (anyNA(df_out$pval)) {
      warning("prob_lower column contains NA")
    }

    df_out <- df_out %>%
      group_by(.data$study_id) %>%
      arrange(.data$study_id, .data$prob_low) %>%
      mutate(
        prob_low_adj = p.adjust(.data$prob_low, method = method),
        prob_low_prob_ur = 1 - .data$prob_low_adj
      )
  }

  return(ungroup(df_out))
}


#' @title evaluate sites
#' @description correct under-reporting probabilities by the expected number of
#'   false positives (fp). This has been deprecated in favor of more conventional
#'   methods available via p.adjust().
#' @param df_sim_sites dataframe generated by [sim_sites()][sim_sites()]
#' @param r_sim_sites integer, number of repeats for bootstrap resampling for site
#'   simulation, needed for zero probability correction for fp calculation, Default: 1000
#' @return dataframe with the following columns:
#' \describe{
#'   \item{**study_id**}{study identification}
#'   \item{**site_number**}{site identification}
#'   \item{**visit_med75**}{median(max(visit)) * 0.75}
#'   \item{**mean_ae_site_med75**}{mean AE at visit_med75 site level}
#'   \item{**mean_ae_study_med75**}{mean AE at visit_med75 study level}
#'   \item{**pval**}{p-value as returned by `poisson.test`}
#'   \item{**prob_low**}{bootstrapped probability for having mean_ae_site_med75 or lower}
#'   \item{**n_site**}{number of study sites}
#'   \item{**pval_n_detected**}{sites with the same p-value or lower}
#'   \item{**pval_fp**}{expected number of fp, pval * n_site}
#'   \item{**pval_p_vs_fp_ratio**}{odds under-reporting as p/fp, poisson.test (use as benchmark)}
#'   \item{**pval_prob_ur**}{probability under-reporting as 1 - fp/p, poisson.test (use as benchmark)}
#'   \item{**prob_low_n_detected**}{sites with same bootstrapped probability or lower}
#'   \item{**prob_low_fp**}{expected number of fp, prob_lower * n_site}
#'   \item{**prob_low_p_vs_fp_ratio**}{odds under-reporting as p/fp, bootstrapped (use)}
#'   \item{**prob_low_prob_ur**}{probability under-reporting as 1 - fp/p, bootstrapped (use)}
#' }
#' @details If by chance expected number of
#'   false positives (fp) is greater than the total number of positives (p) we
#'   set p_vs_fp_ratio = 1 and prob_ur = 0.
#' @examples
#' df_visit <- sim_test_data_study(n_pat = 100, n_sites = 5,
#'     frac_site_with_ur = 0.4, ur_rate = 0.6)
#'
#' df_visit$study_id <- "A"
#' df_site <- site_aggr(df_visit)
#'
#' df_sim_sites <- sim_sites(df_site, df_visit, r = 100)
#'
#' df_eval <- eval_sites(df_sim_sites, r_sim_sites = 100)
#' df_eval
#' @rdname eval_sites_deprecated
#' @seealso [site_aggr()][site_aggr()], [sim_sites()][sim_sites()]
#' @export
eval_sites_deprecated <- function(df_sim_sites,
                                  r_sim_sites) {


  df_out <- df_sim_sites

  if ("pval" %in% names(df_out)) {

    if (anyNA(df_out$pval)) {
      warning("pval column contains NA")
    }

    df_out <- df_out %>%
      group_by(.data$study_id) %>%
      arrange(.data$study_id, .data$pval) %>%
      mutate(
        n_site = n(),
        min_pval = min(.data$pval[.data$pval > 0]),
        # we need to use ties.method max because there can be more than one site with a
        # specific p value
        pval_n_detected = rank(.data$pval, ties.method = "max", na.last = "keep"),
        pval_fp = .data$pval * .data$n_site,
        pval_fp = ifelse(.data$pval_fp == 0, .data$min_pval / 10, .data$pval_fp),
        pval_p_vs_fp_ratio = .data$pval_n_detected / .data$pval_fp,
        pval_p_vs_fp_ratio = ifelse(is.na(.data$pval_p_vs_fp_ratio) & ! is.na(.data$pval),
                                    0, .data$pval_p_vs_fp_ratio),
        # it is possible to get ratios lower than one if p < expected fp
        # this can happen by chance and is meaningless
        pval_p_vs_fp_ratio = ifelse(.data$pval_p_vs_fp_ratio < 1, 1, .data$pval_p_vs_fp_ratio),
        pval_prob_ur = 1 - 1 / .data$pval_p_vs_fp_ratio
      ) %>%
      select(- .data$min_pval)
  }

  if ("prob_low" %in% names(df_out)) {

    if (anyNA(df_out$pval)) {
      warning("prob_lower column contains NA")
    }

    df_out <- df_out %>%
      group_by(.data$study_id) %>%
      arrange(.data$study_id, .data$prob_low) %>%
      mutate(
        n_site = n(),
        # we need to use ties.method max because there can be more than one site with a
        # specific prob_low value
        prob_low_n_detected = rank(.data$prob_low, ties.method = "max", na.last = "keep"),
        prob_low_fp = .data$prob_low * .data$n_site,
        prob_low_fp = ifelse(.data$prob_low_fp == 0, 1 / r_sim_sites / 10, .data$prob_low_fp),
        prob_low_p_vs_fp_ratio = .data$prob_low_n_detected / .data$prob_low_fp,
        prob_low_p_vs_fp_ratio = ifelse(is.na(.data$prob_low_p_vs_fp_ratio) & ! is.na(.data$prob_low),
                                        0, .data$prob_low_p_vs_fp_ratio),
        # it is possible to get ratios lower than one if p < expected fp
        # this can happen by chance and is meaningless
        prob_low_p_vs_fp_ratio = ifelse(.data$prob_low_p_vs_fp_ratio < 1, 1, .data$prob_low_p_vs_fp_ratio),
        prob_low_prob_ur = 1 - 1 / .data$prob_low_p_vs_fp_ratio
      )
  }

  return(ungroup(df_out))
}

#' @title get empirical cumulative distribution values of pval or prob_lower
#' @description test function, test applicability of poisson test, by calculating
#' a the bootstrapped probability of obtaining a specific p-value or lower, use
#' in combination with [sim_studies()][sim_studies()].
#' @param df_sim_studies dataframe, generated by [sim_studies()][sim_studies()]
#' @param df_sim_sites dataframe, generated by [sim_sites()][sim_sites()]
#' @param val_str c("prob_low","pval")
#' @return dataframe with the following columns:
#' \describe{
#'   \item{**study_id**}{study identification}
#'   \item{**site_number**}{site identification}
#'   \item{**visit_med75**}{median(max(visit)) * 0.75}
#'   \item{**mean_ae_site_med75**}{mean AE at visit_med75 site level}
#'   \item{**mean_ae_study_med75**}{mean AE at visit_med75 study level}
#'   \item{**{pval/prob_low}**}{p-value as returned by `poisson.test`}
#'   \item{**{pval/prob_low}_ecd**}{p-value as returned by `poisson.test`}
#' }
#' @details trains a ecdf function for each studies based on the results
#' of [sim_studies()][sim_studies()]
#' @examples
#' df_visit <- sim_test_data_study(n_pat = 100, n_sites = 5,
#'     frac_site_with_ur = 0.4, ur_rate = 0.3)
#'
#' df_visit$study_id <- "A"
#' df_site <- site_aggr(df_visit)
#'
#' df_sim_sites <- sim_sites(df_site, df_visit, r = 100)
#'
#' df_sim_studies <- sim_studies(
#'   df_site = df_site,
#'   df_visit = df_visit,
#'   r = 3,
#'   parallel = FALSE,
#'   poisson_test = TRUE,
#'   prob_lower = TRUE
#' )
#'
#' get_ecd_values(df_sim_studies, df_sim_sites, "prob_low")
#' get_ecd_values(df_sim_studies, df_sim_sites, "pval")
#' @rdname get_ecd_values
#' @export

get_ecd_values <- function(df_sim_studies, df_sim_sites, val_str) {

  possibly_ecdf <- possibly(ecdf, otherwise = NA)

  apply_ecdf <- function(.f, x) {
      if (suppressWarnings(is.na(.f))) {
        warning("NA Values in Stats")
        return(NA)
      } else {
        return(.f(x))
      }
  }

  df_ecd <- df_sim_studies %>%
    rename(val = !!as.symbol(val_str)) %>%
    select(.data$study_id, .data$val) %>%
    nest(data = c(.data$val)) %>%
    mutate(.ecdf = map(.data$data, ~ possibly_ecdf(.$val))) %>%
    select(- .data$data)

  df_out <- df_sim_sites %>%
    rename(val = !!as.symbol(val_str)) %>%
    left_join(df_ecd, "study_id") %>%
    mutate(ecd_val = map2_dbl(.data$`.ecdf`, .data$val, apply_ecdf)) %>%
    rename(
      !!as.symbol(val_str) := .data$val,
      !!as.symbol(paste0(val_str, "_ecd")) := .data$ecd_val
    ) %>%
    select(- .data$`.ecdf`)

  return(ungroup(df_out))
}



#' @title create patient pool for sampling for simulations
#' @description helper function for [sim_sites()][sim_sites()], filter all visits greater than max_visit_med75_study
#' returns dataframe with one column for studies and one column with nested
#' patient data.
#' @param df_visit dataframe, created by [sim_sites()][sim_sites()]
#' @param df_site dataframe created by [site_aggr()][site_aggr()]
#' @return dataframe with nested pat_pool column
#' @examples
#' df_visit <- sim_test_data_study(n_pat = 100, n_sites = 5,
#'     frac_site_with_ur = 0.4, ur_rate = 0.6)
#'
#' df_visit$study_id <- "A"
#' df_site <- site_aggr(df_visit)
#'
#' df_pat_pool <- pat_pool(df_visit, df_site)
#' df_pat_pool
#' @rdname pat_pool
#' @export
pat_pool <- function(df_visit, df_site) {
  df_site <- df_site %>%
    group_by(.data$study_id) %>%
    mutate(max_visit_med75_study = max(.data$visit_med75))

  df_visit %>%
    left_join(df_site, by = c("study_id", "site_number")) %>%
    filter(.data$visit <= .data$max_visit_med75_study) %>%
    select(.data$study_id,
           .data$patnum,
           .data$visit,
           .data$n_ae) %>%
    nest(pat_pool = c(.data$patnum, .data$visit, .data$n_ae))
}




#' @title calculate bootstrapped probability for obtaining a lower mean AE
#' @description helper function used by [sim_sites()][sim_sites()]
#' @param site_ae vector with AE numbers
#' @param study_ae vector with AE numbers
#' @param r integer, denotes number of simulations, default = 1000
#' @param parallel logical, toggles parallel processing on and of, default = F
#' @return pval
#' @details sets pvalue=1 if mean AE site is greater than mean AE study
#' @examples
#' prob_lower_site_ae_vs_study_ae(
#'   site_ae = c(5, 3, 3, 2, 1, 6),
#'   study_ae = c(9, 8, 7, 9, 6, 7, 8),
#'   parallel = FALSE
#' )
#' @seealso \code{\link[purrr]{safely}}
#' @rdname prob_lower_site_ae_vs_study_ae
#' @export
#' @importFrom purrr safely
prob_lower_site_ae_vs_study_ae <- function(site_ae, study_ae, r = 1000, parallel = FALSE) {

  # if there is only one site
  if (is_null(study_ae)) {
    prob_lower <- 1
    return(prob_lower)
  }

  mean_ae_site <- mean(site_ae, na.rm = T)
  mean_ae_study <- mean(study_ae, na.rm = T)

  # we are not interested in cases where site AE is greater study AE
  if (mean_ae_site > mean_ae_study) {
    prob_lower <- 1
    return(prob_lower)
  }

  # set-up multiprocessing
  # multiprocessing currently not used by sim_sites()
  if (parallel) {
    requireNamespace("furrr")
    suppressWarnings(future::plan(multiprocess))
    .f_map_int <- function(...) {
        furrr::future_map_int(..., .options = furrr_options(seed = TRUE))
      }
  } else {
    .f_map_int <- purrr::map_int
  }

  pool <- c(site_ae, study_ae)
  n_pat <- length(site_ae)

  sim <- function(seed) {
    set.seed(seed)
    me <- mean(sample(pool, n_pat, replace = T))
    # '<=' includes all cases where mean_ae_site == 0 and me also == 0
    return(as.integer(ifelse(me <= mean_ae_site, 1, 0)))
  }

  df_sim <- tibble(seed = seq.int(1, r, 1)) %>%
    mutate(prob_lower = .f_map_int(.data$seed, .f = sim)) %>%
    summarise(prob_lower = sum(.data$prob_lower) / r)

  return(df_sim$prob_lower)
}


#' @title calculate prob_lower and poisson.test pvalue for study sites
#' @description collects the number of AEs of all eligible patients that
#'   meet visit_med75 criteria of site. Then  calculates poisson.test pvalue and
#'   bootstrapped probability of having a lower mean value.
#' @param df_visit dataframe, created by [sim_sites()][sim_sites()]
#' @param df_site dataframe created by [site_aggr()][site_aggr()]
#' @param r integer, denotes number of simulations, default = 1000
#' @param poisson_test logical, calculates poisson.test pvalue
#' @param prob_lower logical, calculates probability for getting a lower value
#' @return dataframe with the following columns:
#' \describe{
#'   \item{**study_id**}{study identification}
#'   \item{**site_number**}{site identification}
#'   \item{**visit_med75**}{median(max(visit)) * 0.75}
#'   \item{**mean_ae_site_med75**}{mean AE at visit_med75 site level}
#'   \item{**mean_ae_study_med75**}{mean AE at visit_med75 study level}
#'   \item{**pval**}{p-value as returned by `poisson.test`}
#'   \item{**prob_low**}{bootstrapped probability for having mean_ae_site_med75 or lower}
#'  }
#' @examples
#' df_visit <- sim_test_data_study(n_pat = 100, n_sites = 5,
#'     frac_site_with_ur = 0.4, ur_rate = 0.2)
#' df_visit$study_id <- "A"
#' df_site <- site_aggr(df_visit)
#' df_sim_sites <- sim_sites(df_site, df_visit, r = 100)
#' df_sim_sites
#' @rdname sim_sites
#' @export
#' @import dplyr
#' @import purrr
#' @import tidyr
sim_sites <- function(df_site,
                      df_visit,
                      r = 1000,
                      poisson_test = TRUE,
                      prob_lower = TRUE) {

  df_pat_pool <- pat_pool(df_visit, df_site)

  df_sim_prep <- df_visit %>%
    left_join(select(df_site,
                     .data$study_id,
                     .data$site_number,
                     .data$visit_med75),
      by = c("study_id", "site_number")
    ) %>%
    filter(.data$visit == .data$visit_med75) %>%
    group_by(.data$study_id,
             .data$site_number,
             .data$visit_med75) %>%
    summarise(patients = list(unique(.data$patnum)))

  df_sim_prep <- df_sim_prep %>%
    left_join(df_pat_pool, "study_id") %>%
    mutate(
      pat_pool = map2(.data$pat_pool, .data$visit_med75, function(x, y) filter(x, .data$visit == y)),
      n_ae_site = map2(.data$pat_pool, .data$patients, function(x, y) filter(x, .data$patnum %in% y)),
      n_ae_study = map2(.data$pat_pool, .data$patients, function(x, y) filter(x, ! .data$patnum %in% y)),
      n_ae_site = map(.data$n_ae_site, "n_ae"),
      n_ae_study = map(.data$n_ae_study, "n_ae")
    ) %>%
    select(- .data$patients,
           - .data$pat_pool)

  df_sim <- df_sim_prep

  if (poisson_test) {
    df_sim <- df_sim %>%
      mutate(pval = pmap_dbl(list(.data$n_ae_site, .data$n_ae_study, .data$visit_med75),
                             poiss_test_site_ae_vs_study_ae))
  }

  if (prob_lower) {
    df_sim <- df_sim %>%
      mutate(prob_low = map2_dbl(.data$n_ae_site, .data$n_ae_study,
        prob_lower_site_ae_vs_study_ae,
        r = r
      ))
  }

  df_sim %>%
    mutate(mean_ae_site_med75 = map_dbl(n_ae_site, mean),
           mean_ae_study_med75 = map_dbl(n_ae_study, mean)) %>%
    select(- n_ae_site, - n_ae_study) %>%
    select(.data$study_id,
           .data$site_number,
           .data$visit_med75,
           .data$mean_ae_site_med75,
           .data$mean_ae_study_med75,
           everything()) %>%
    ungroup() %>%
    return()
}

#' @title configure study patient pool by site parameters
#' @description for simulating a study we need to configure the study patient
#'   pool to match the configuration of the sites
#' @param df_visit dataframe
#' @param df_site dataframe as created by site_aggr()
#' @param min_n_pat_with_med75 minimum number of patients with visit_med_75 for
#'   simulation, Default: 1
#' @return OUTPUT_DESCRIPTION
#' @details DETAILS
#' @examples
#' df_visit1 <- sim_test_data_study(n_pat = 100, n_sites = 5,
#'                                       frac_site_with_ur = 0.4, ur_rate = 0.6)
#'
#' df_visit1$study_id <- "A"
#'
#' df_visit2 <- sim_test_data_study(n_pat = 1000, n_sites = 3,
#'                                       frac_site_with_ur = 0.2, ur_rate = 0.1)
#'
#' df_visit2$study_id <- "B"
#'
#' df_visit <- bind_rows(df_visit1, df_visit2)
#'
#' df_site <- site_aggr(df_visit)
#'
#' df_config <- get_pat_pool_config(df_visit, df_site)
#'
#' df_config
#' @rdname get_pat_pool_config
#' @export
get_pat_pool_config <- function(df_visit, df_site, min_n_pat_with_med75 = 1) {

  # site_config are the number of sites with their individual visit_med75 and n_pat_with_med75
  df_site_config <- select(df_site,
                           .data$study_id,
                           .data$site_number,
                           .data$visit_med75,
                           .data$n_pat_with_med75) %>%
    filter(.data$n_pat_with_med75 >= min_n_pat_with_med75)

  # pat_pool gives the patient pool for study from which we sample
  df_site_config <- df_site_config %>%
    left_join(pat_pool(df_visit, df_site), by = "study_id")

  # adjusting pat_pool to configuration can be done outside of simulation loop

  df_site_config <- df_site_config %>%
    mutate(
      pat_pool = map2(.data$pat_pool, .data$visit_med75, function(x, y) filter(x, visit == y)),
      n_pat_study = map2_dbl(.data$pat_pool, .data$n_pat_with_med75, function(x, y) nrow(x) - y)
    ) %>%
    select(.data$study_id,
           .data$site_number,
           .data$visit_med75,
           .data$n_pat_with_med75,
           .data$n_pat_study,
           .data$pat_pool)

  return(ungroup(df_site_config))
}

#' @title simulate studies
#' @description test function, test applicability of poisson test, by
#'   calculating a the bootstrapped probability of obtaining a specific p-value
#'   or lower, use in combination with [get_ecd_values()][get_ecd_values()].
#' @param df_site dataframe
#' @param df_visit dataframe
#' @param min_n_pat_with_med75 integer, min number of patients with med75 at
#'   site to simulate, Default: 1
#' @param keep_ae logical, keep ae numbers in output dataframe memory increase
#'   roughly 30 percent, Default: F
#' @param parallel logical, see examples for registering parallel processing framework
#' , Default: FALSE
#' @param r integer, denotes number of simulations, Default: 1000
#' @param r_prob_lower integer, denotes number of simulations for prob_lower
#'   value calculation,, Default: 1000
#' @param poisson_test logical, calculates poisson.test pvalue, Default: TRUE
#' @param prob_lower logical, calculates probability for getting a lower value,
#'   Default: FALSE
#' @param studies vector with study names, Default: NULL
#' @param .progress logical, show progress bar
#' @details Here we simulate study replicates maintaining the same number of
#'   sites, patients and visit_med75 by bootstrap resampling, then probabilities
#'   for obtaining lower or same mean_ae count and p-values using poisson.test
#'   are calculated.
#' @return dataframe
#' @examples
#' df_visit1 <- sim_test_data_study(n_pat = 100, n_sites = 5,
#'                                       frac_site_with_ur = 0.4, ur_rate = 0.6)
#'
#' df_visit1$study_id <- "A"
#'
#' df_visit2 <- sim_test_data_study(n_pat = 1000, n_sites = 3,
#'                                       frac_site_with_ur = 0.2, ur_rate = 0.1)
#'
#' df_visit2$study_id <- "B"
#'
#' df_visit <- bind_rows(df_visit1, df_visit2)
#'
#' df_site <- site_aggr(df_visit)
#'
#' sim_studies(df_visit, df_site, r = 3, keep_ae = TRUE)
#'
#' # parallel processing -------------------------
#' \dontrun{
#' library(future)
#' future::plan(multiprocess)
#' sim_studies(df_visit, df_site, r = 3, keep_ae = TRUE, parallel = TRUE)
#'}
#' @details  adds column with simulated probabilities for equal or lower
#'   mean_ae at visit_med75
#' @rdname sim_studies
#' @export
#' @importFrom feather read_feather write_feather
#' @import dplyr
#' @import purrr
#' @import tidyr
#' @import furrr
#' @import future
#' @importFrom stringr str_count str_pad
#' @importFrom rlang :=
sim_studies <- function(df_visit,
                        df_site,
                        r = 100,
                        poisson_test = TRUE,
                        prob_lower = TRUE,
                        r_prob_lower = 1000,
                        parallel = FALSE,
                        keep_ae = FALSE,
                        min_n_pat_with_med75 = 1,
                        studies = NULL,
                        .progress = TRUE
                        ) {

  df_config <- get_pat_pool_config(df_visit = df_visit,
                                   df_site = df_site,
                                   min_n_pat_with_med75 = min_n_pat_with_med75)

  # filter studies --------------------------------------------
  if (!is_null(studies)) {
    if (!all(studies %in% unique(df_visit$study_id))) {
      stop("not all passed studies can be found in input data")
    }

    df_config <- df_config %>%
      filter(.data$study_id %in% studies)

  }

  # set-up multiprocessing -------------------------------------
  if (parallel) {
    requireNamespace("furrr")
    suppressWarnings(future::plan(multiprocess))
    .f_map <- function(...) {
      furrr::future_map(
        ...,
        .progress = .progress,
        .options = furrr_options(seed = TRUE)
      )
    }
  } else {
    .f_map <- purrr::map
  }

  # sim function will be called r times -----------------------
  sim <- function(r) {
    set.seed(r)
    df_config <- df_config %>%
      mutate(
        n_ae_site = map2(.data$pat_pool, .data$n_pat_with_med75,
                         function(x, y) sample_n(x, y, replace = TRUE)),
        n_ae_site = map(.data$n_ae_site, "n_ae"),
        n_ae_study = map2(.data$pat_pool, .data$n_pat_study,
                          function(x, y) sample_n(x, y, replace = TRUE)),
        n_ae_study = map(.data$n_ae_study, "n_ae")
      ) %>%
      select(- .data$pat_pool)

    if (poisson_test) {
      df_config <- df_config %>%
        mutate(pval = pmap_dbl(list(.data$n_ae_site,
                               .data$n_ae_study,
                               .data$visit_med75),
                               poiss_test_site_ae_vs_study_ae))
    }

    if (prob_lower) {
      df_config <- df_config %>%
        mutate(prob_low = map2_dbl(.data$n_ae_site, .data$n_ae_study,
                                   prob_lower_site_ae_vs_study_ae,
                                   r = r_prob_lower))
    }

    if (!keep_ae) {
      df_config <- df_config %>%
        select(- .data$n_ae_site, - .data$n_ae_study)
    } else {
      df_config <- df_config %>%
        mutate_at(vars(n_ae_site, n_ae_study), ~ map_chr(., paste, collapse = ","))
    }

    return(ungroup(df_config))
  }

  df_sim <- tibble(r = seq.int(1, r, 1)) %>%
    mutate(n_ae_set = .f_map(.data$r, sim)) %>%
    unnest(.data$n_ae_set)

  return(ungroup(df_sim))
}



#' @title aggregate from visit to site level
#' @description calculates visit_med75, n_pat_with_med75 and mean_ae_site_med75
#' @param df_visit dataframe with columns: study_id, site_number, patnum, visit, n_ae
#' @return dataframe with the following columns:
#' \describe{
#'   \item{**study_id**}{study identification}
#'   \item{**site_number**}{site identification}
#'   \item{**n_patients**}{number of patients, site level}
#'   \item{**visit_med75**}{median(max(visit)) * 0.75}
#'   \item{**n_pat_with_med75**}{number of patients that meet visit_med75 criterion, site level}
#'   \item{**mean_ae_site_med75**}{mean AE at visit_med75, site level}
#'}
#' @examples
#' df_visit <- sim_test_data_study(n_pat = 100, n_sites = 5,
#'     frac_site_with_ur = 0.4, ur_rate = 0.6)
#' df_visit$study_id <- "A"
#' df_site <- site_aggr(df_visit)
#' df_site
#' @rdname site_aggr
#' @export
site_aggr <- function(df_visit) {

  stopifnot(
    all(c("study_id", "site_number", "patnum", "n_ae", "visit") %in% names(df_visit))
  )

  # Aggregate on site level ------------------------------------------

  df_visit <- df_visit %>%
    group_by(.data$study_id, .data$site_number, .data$patnum) %>%
    mutate(max_visit_per_pat = max(.data$visit))

  df_pat <- df_visit %>%
    select(.data$study_id,
           .data$site_number,
           .data$patnum,
           .data$max_visit_per_pat) %>%
    distinct()

  df_site <- df_pat %>%
    group_by(.data$study_id, .data$site_number) %>%
    mutate(
      n_patients = n_distinct(.data$patnum)
      # , visit_min = min(max_visit_per_pat)
      # , visit_median = median(max_visit_per_pat)
      # , visit_mean = mean(max_visit_per_pat)
      # , visit_max = max(max_visit_per_pat)
      , visit_med75 = ceiling(median(.data$max_visit_per_pat) * 0.75),
      n_pat_with_med75 = ifelse(.data$max_visit_per_pat >= .data$visit_med75, 1, 0),
      n_pat_with_med75 = sum(.data$n_pat_with_med75)
      # , freq_pat_with_med75 = n_pat_with_med75 / n_patients
    ) %>%
    select(- .data$patnum,
           - .data$max_visit_per_pat) %>%
    distinct()

  # Calculate mean cumulative AE at med75 per Site ------------------

  df_mean_ae_dev <- df_visit %>%
    left_join(df_site, by = c("study_id", "site_number")) %>%
    filter(.data$visit <= .data$visit_med75, .data$max_visit_per_pat >= .data$visit_med75) %>%
    group_by(.data$study_id, .data$site_number, .data$visit_med75, .data$visit) %>%
    summarise(mean_ae_site = mean(.data$n_ae)) %>%
    ungroup()

  df_mean_ae_med75 <- df_mean_ae_dev %>%
    filter(.data$visit == .data$visit_med75) %>%
    rename(mean_ae_site_med75 = .data$mean_ae_site) %>%
    select(.data$study_id,
           .data$site_number,
           .data$mean_ae_site_med75)

  # Add mean cumulative AE to site aggregate ----------------------

  df_site <- df_site %>%
    left_join(df_mean_ae_med75, by = c("study_id", "site_number"))

  return(ungroup(df_site))
}



#' @title poisson test for vector with site AEs vs vector with study AEs
#' @description helper function used by [sim_sites()][sim_sites()]
#' @param site_ae vector with AE numbers
#' @param study_ae vector with AE numbers
#' @param visit_med75 integer
#' @return pval
#' @details sets pvalue=1 if mean AE site is greater than mean AE study or ttest gives error
#' @examples
#' poiss_test_site_ae_vs_study_ae(
#'    site_ae = c(5, 3, 3, 2, 1, 6),
#'    study_ae = c(9, 8, 7, 9, 6, 7, 8),
#'    visit_med75 = 10
#')
#'
#' poiss_test_site_ae_vs_study_ae(
#'    site_ae = c(11, 9, 8, 6, 3),
#'    study_ae = c(9, 8, 7, 9, 6, 7, 8),
#'    visit_med75 = 10
#')
#' @seealso [sim_sites()][sim_sites()]
#' @rdname poiss_test_site_ae_vs_study_ae
#' @export
#' @importFrom purrr safely
#' @importFrom stats median runif poisson.test

poiss_test_site_ae_vs_study_ae <- function(site_ae,
                                             study_ae,
                                             visit_med75) {

  # if there is only one site
  if (is_null(study_ae)) {
    pval <- 1
    return(pval)
  }

  mean_ae_site <- mean(site_ae, na.rm = T)
  mean_ae_study <- mean(study_ae, na.rm = T)

  # we are not interested in cases where site AE is greater study AE
  if (mean_ae_site > mean_ae_study) {
    pval <- 1
    return(pval)
  }

  n_pat_site <- length(site_ae)
  n_pat_study <- length(study_ae)

  time_base_site <- n_pat_site * visit_med75
  time_base_study <- n_pat_study * visit_med75

  n_events_site <- sum(site_ae)
  n_events_study <- sum(study_ae)

  safely_poisson_test <- purrr::safely(poisson.test)

  poisson_test <- safely_poisson_test(c(n_events_site, n_events_study),
                                      c(time_base_site, time_base_study))

  pval <- poisson_test$result$p.value

  # this controls for cases when poisson.test fails for some reason
  if (is_null(pval)) {
    pval <- 1
  }

  return(pval)
}


#' @title simulate study test data
#' @description evenly distributes a number of given patients across a number of
#'   given sites. Then simulates ae development of each patient reducing the
#'   number of reported AEs for patients distributed to AE-under-reporting sites.
#' @param n_pat integer, number of patients, Default: 1000
#' @param n_sites integer, number of sites, Default: 20
#' @param frac_site_with_ur fraction of AE under-reporting sites, Default: 0
#' @param ur_rate AE under-reporting rate, will lower mean ae per visit used to
#'   simulate patients at sites flagged as AE-under-reporting., Default: 0
#' @param max_visit_mean mean of the maximum number of visits of each patient,
#'   Default: 20
#' @param max_visit_sd standard deviation of maximum number of visits of each
#'   patient, Default: 4
#' @param ae_per_visit_mean mean ae per visit per patient, Default: 0.5
#' @return tibble with columns site_number, patnum, is_ur, max_visit_mean,
#'   max_visit_sd, ae_per_visit_mean, visit, n_ae
#' @details maximum visit number will be sampled from normal distribution with
#'   characteristics derived from max_visit_mean and max_visit_sd, while the ae
#'   per visit will be sampled from a poisson distribution described by
#'   ae_per_visit_mean.
#' @examples
#' set.seed(1)
#' df_visit <- sim_test_data_study(n_pat = 100, n_sites = 5)
#' df_visit[which(df_visit$patnum == "P000001"),]
#' df_visit <- sim_test_data_study(n_pat = 100, n_sites = 5,
#'     frac_site_with_ur = 0.2, ur_rate = 0.5)
#' df_visit[which(df_visit$patnum == "P000001"),]
#' @rdname sim_test_data_study
#' @export
sim_test_data_study <- function(n_pat = 1000,
                                     n_sites = 20,
                                     frac_site_with_ur = 0,
                                     ur_rate = 0,
                                     max_visit_mean = 20,
                                     max_visit_sd = 4,
                                     ae_per_visit_mean = 0.5
                                     ) {
  tibble(patnum = seq(1, n_pat)) %>%
    mutate(patnum = str_pad(patnum, width = 6, side = "left", pad = "0"),
           patnum = paste0("P", patnum),
           site_number = seq(1, n_pat),
           site_number = cut(.data$site_number, n_sites, labels = FALSE),
           is_ur = ifelse(.data$site_number <= (max(.data$site_number) * frac_site_with_ur), TRUE, FALSE),
           site_number = str_pad(.data$site_number, width = 4, side = "left", pad = "0"),
           site_number = paste0("S", .data$site_number),
           max_visit_mean = max_visit_mean,
           max_visit_sd = max_visit_sd,
           ae_per_visit_mean = ifelse(.data$is_ur, ae_per_visit_mean * (1 - ur_rate), ae_per_visit_mean),
           aes = pmap(list(vm = max_visit_mean,
                           vs = max_visit_sd,
                           am = ae_per_visit_mean),
                      function(vm, vs, am) sim_test_data_patient(
                        .f_sample_max_visit = function() rnorm(1, mean = vm, sd = vs),
                        .f_sample_ae_per_visit = function(max_visit) rpois(max_visit, am))),
           aes = map(aes, ~ tibble(visit = seq(1, length(.)), n_ae = .))) %>%
    unnest(aes)

}

#' @title simulate patient ae reporting test data
#' @description helper function for [sim_test_data_study()][sim_test_data_study()]
#' @param .f_sample_ae_per_visit function used to sample the aes for each visit,
#'   Default: function(x) rpois(x, 0.5)
#' @param .f_sample_max_visit function used to sample the maximum number of aes,
#'   Default: function() rnorm(1, mean = 20, sd = 4)
#' @return vector containing cumulative aes
#' @details ""
#' @examples
#' replicate(5, sim_test_data_patient())
#' replicate(5, sim_test_data_patient(
#'     .f_sample_ae_per_visit = function(x) rpois(x, 1.2))
#'   )
#' replicate(5, sim_test_data_patient(
#'     .f_sample_max_visit = function() rnorm(1, mean = 5, sd = 5))
#'   )
#' @importFrom stats ecdf rnorm rpois
#' @rdname sim_test_data_patient
#' @export
sim_test_data_patient <- function(.f_sample_max_visit = function() rnorm(1, mean = 20, sd = 4),
                                       .f_sample_ae_per_visit = function(max_visit) rpois(max_visit, 0.5)) {

  max_visit <- as.integer(.f_sample_max_visit())
  max_visit <- ifelse(max_visit < 1, 1, max_visit)
  aes <- .f_sample_ae_per_visit(max_visit)
  cum_aes <- cumsum(aes)

  return(cum_aes)
}
